generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model User {
  id                 String              @id @default(cuid())
  email              String              @unique
  password           String?
  firstName          String?
  lastName           String?
  role               UserRole            @default(TENANT)
  phone              String?
  firebaseUid        String?             @unique
  createdAt          DateTime            @default(now())
  updatedAt          DateTime            @updatedAt
  budgetMax          Int?
  budgetMin          Int?
  petPreferences     Json?
  preferredBedrooms  Int?
  preferredLocations String[]            @default([])
  profilePreferences Json?
  profileUpdatedAt   DateTime?
  applications       Application[]       @relation("ApplicantApplications")
  leases             Lease[]             @relation("TenantLeases")
  maintenanceTickets MaintenanceTicket[] @relation("TenantTickets")
  payments           Payment[]           @relation("TenantPayments")
  properties         Property[]          @relation("LandlordProperties")
  reminders          ReminderSchedule[]
  tenantReminders    ReminderSchedule[]  @relation("TenantReminder")
  assignedLeads      Lead[]              @relation("AssignedLeads")
  documents          Document[]          @relation("UserDocuments")
  chatSessions       ChatSession[]       @relation("UserChatSessions")

  @@index([email])
  @@index([firebaseUid])
  @@index([role])
  @@map("users")
}

model Property {
  id                 String              @id @default(cuid())
  title              String?
  description        String?
  bedrooms           Int?
  bathrooms          Int?
  squareFeet         Int?
  rentAmount         Float?
  rentCurrency       String              @default("USD")
  deposit            Float               @default(0)
  addressStreet      String?
  addressCity        String?
  addressState       String?
  addressZip         String?
  addressCountry     String              @default("US")
  propertyType       PropertyType        @default(APARTMENT)
  status             PropertyStatus      @default(ACTIVE)
  isAvailable        Boolean             @default(true)
  availableFrom      DateTime?
  availableTo        DateTime?
  amenities          Json?
  images             Json?
  petPolicy          String?
  utilities          Json?
  latitude           Float?
  longitude          Float?
  landlordId         String
  createdAt          DateTime            @default(now())
  updatedAt          DateTime            @updatedAt
  applications       Application[]       @relation("PropertyApplications")
  leases             Lease[]             @relation("PropertyLeases")
  maintenanceTickets MaintenanceTicket[] @relation("PropertyTickets")
  reminders          ReminderSchedule[]
  documents          Document[]          @relation("PropertyDocuments")
  landlord           User                @relation("LandlordProperties", fields: [landlordId], references: [id])

  @@index([landlordId])
  @@index([status])
  @@index([isAvailable])
  @@index([propertyType])
  @@map("properties")
}

model Lease {
  id              String      @id @default(cuid())
  startDate       DateTime
  endDate         DateTime
  monthlyRent     Float
  securityDeposit Float?
  status          LeaseStatus @default(ACTIVE)
  terms           String?
  notes           String?
  propertyId      String
  tenantId        String
  createdAt       DateTime    @default(now())
  updatedAt       DateTime    @updatedAt
  property        Property    @relation("PropertyLeases", fields: [propertyId], references: [id])
  tenant          User        @relation("TenantLeases", fields: [tenantId], references: [id])
  payments        Payment[]   @relation("LeasePayments")
  reminders       ReminderSchedule[]

  @@index([propertyId])
  @@index([tenantId])
  @@index([status])
  @@index([startDate])
  @@index([endDate])
  @@map("leases")
}

model Payment {
  id          String        @id @default(cuid())
  amount      Float
  dueDate     DateTime
  paidDate    DateTime?
  status      PaymentStatus @default(PENDING)
  type        PaymentType   @default(RENT)
  description String?
  late        Boolean       @default(false)
  lateFee     Float?
  leaseId     String?
  tenantId    String
  createdAt   DateTime      @default(now())
  updatedAt   DateTime      @updatedAt
  lease       Lease?        @relation("LeasePayments", fields: [leaseId], references: [id])
  tenant      User          @relation("TenantPayments", fields: [tenantId], references: [id])

  @@index([leaseId])
  @@index([tenantId])
  @@index([status])
  @@index([dueDate])
  @@index([type])
  @@map("payments")
}

model MaintenanceTicket {
  id            String       @id @default(cuid())
  title         String
  description   String
  priority      Priority     @default(MEDIUM)
  status        TicketStatus @default(OPEN)
  category      String?
  estimatedCost Float?
  actualCost    Float?
  assignedTo    String?
  completedAt   DateTime?
  propertyId    String
  tenantId      String
  createdAt     DateTime     @default(now())
  updatedAt     DateTime     @updatedAt
  property      Property     @relation("PropertyTickets", fields: [propertyId], references: [id])
  tenant        User         @relation("TenantTickets", fields: [tenantId], references: [id])

  @@index([propertyId])
  @@index([tenantId])
  @@index([status])
  @@index([priority])
  @@index([assignedTo])
  @@map("maintenance_tickets")
}

model Application {
  id                  String            @id @default(cuid())
  propertyId          String
  applicantId         String?
  firstName           String
  lastName            String
  email               String
  phone               String
  dateOfBirth         DateTime
  currentAddress      String
  currentCity         String
  currentState        String
  currentZip          String
  yearsAtAddress      Float
  reasonForMoving     String?
  employerName        String
  jobTitle            String
  employerAddress     String
  employerPhone       String
  employmentLength    String
  monthlyIncome       Float
  otherIncome         Float?
  prevAddress         String?
  prevLandlordName    String?
  prevLandlordContact String?
  reasonForLeaving    String?
  wasLateRent         Boolean           @default(false)
  refName             String
  refRelationship     String
  refContact          String
  occupants           Int
  pets                Json?
  vehicles            Json?
  wasEvicted          Boolean           @default(false)
  felony              Boolean           @default(false)
  desiredMoveIn       DateTime
  consentBackground   Boolean           @default(false)
  signature           String
  signedAt            DateTime
  status              ApplicationStatus @default(PENDING)
  submittedAt         DateTime          @default(now())
  reviewedAt          DateTime?
  reviewNotes         String?
  createdAt           DateTime          @default(now())
  updatedAt           DateTime          @updatedAt
  applicant           User?             @relation("ApplicantApplications", fields: [applicantId], references: [id])
  property            Property          @relation("PropertyApplications", fields: [propertyId], references: [id])

  @@index([propertyId])
  @@index([applicantId])
  @@index([status])
  @@index([submittedAt])
  @@index([email])
  @@map("applications")
}

model ReminderSchedule {
  id          String            @id @default(cuid())
  type        ReminderType
  channel     ReminderChannel   @default(EMAIL)
  frequency   ReminderFrequency @default(DAILY)
  timezone    String            @default("UTC")
  isActive    Boolean          @default(true)

  // When to run next / last
  nextRunAt   DateTime
  lastRunAt   DateTime?

  // Optional foreign keys to target audience/context
  userId      String?           // points to User if you target user-level reminders
  tenantId    String?
  propertyId  String?
  leaseId     String?

  // Flexible payload for templates/variables
  metaJson    Json              @default("{}")

  // Relations (keep optional to avoid breaking existing data)
  user        User?             @relation(fields: [userId], references: [id])
  tenant      User?             @relation("TenantReminder", fields: [tenantId], references: [id])
  property    Property?         @relation(fields: [propertyId], references: [id])
  lease       Lease?            @relation(fields: [leaseId], references: [id])
  logs        ReminderLog[]

  createdAt   DateTime          @default(now())
  updatedAt   DateTime          @updatedAt

  @@index([isActive, nextRunAt])
  @@index([type, channel])
  @@index([userId])
  @@index([tenantId])
  @@index([propertyId])
  @@index([leaseId])
  @@map("reminder_schedules")
}

// Optional: simple log for assertions (use only if you already read it in tests)
model ReminderLog {
  id           String          @id @default(cuid())
  scheduleId   String
  runAt        DateTime        @default(now())
  channel      ReminderChannel
  status       String          @default("SENT")
  detail       String?         // error or provider response
  metaJson     Json            @default("{}")

  schedule     ReminderSchedule @relation(fields: [scheduleId], references: [id])

  @@index([scheduleId, runAt])
  @@map("reminder_logs")
}

enum UserRole {
  ADMIN
  LANDLORD
  TENANT
  PROPERTY_MANAGER
}

enum PropertyType {
  APARTMENT
  HOUSE
  CONDO
  TOWNHOUSE
  STUDIO
  DUPLEX
  OTHER
}

enum PropertyStatus {
  ACTIVE
  INACTIVE
  MAINTENANCE
  OCCUPIED
  PENDING
}

enum LeaseStatus {
  ACTIVE
  EXPIRED
  TERMINATED
  PENDING
  RENEWED
}

enum PaymentStatus {
  PENDING
  PAID
  OVERDUE
  FAILED
  CANCELLED
}

enum PaymentType {
  RENT
  SECURITY_DEPOSIT
  LATE_FEE
  MAINTENANCE
  UTILITIES
  OTHER
}

enum Priority {
  LOW
  MEDIUM
  HIGH
  URGENT
}

enum TicketStatus {
  OPEN
  IN_PROGRESS
  RESOLVED
  CLOSED
  CANCELLED
}

enum ApplicationStatus {
  PENDING
  APPROVED
  DECLINED
  WITHDRAWN
}

enum ReminderType {
  RENT_DUE
  LEASE_ENDING
  MAINTENANCE_FOLLOWUP
}

enum ReminderChannel {
  EMAIL
  SMS
  BOTH
}

enum ReminderFrequency {
  DAILY
  WEEKLY
  MONTHLY
}

model Lead {
  id             String      @id @default(cuid())
  email          String      @unique
  firstName      String?
  lastName       String?
  phone          String?
  
  // Lead qualification
  budgetMin      Float?
  budgetMax      Float?
  bedrooms       Int?
  bathrooms      Int?
  desiredArea    String?
  moveInDate     DateTime?
  petFriendly    Boolean?
  
  // Lead scoring & status
  score          Int         @default(0) // 0-100
  temperature    LeadTemp    @default(COLD)
  source         String?     // 'website', 'referral', 'ad', etc.
  status         LeadStatus  @default(NEW)
  
  // AI conversation history
  conversationHistory Json   @default("[]")
  lastInteraction     DateTime?
  totalInteractions   Int     @default(0)
  
  // Assignment & follow-up
  assignedToId   String?
  assignedTo     User?       @relation("AssignedLeads", fields: [assignedToId], references: [id])
  
  // Property interest tracking
  interestedProperties String[] @default([])
  viewedProperties     String[] @default([])
  
  // Metadata
  metaData       Json        @default("{}")
  
  createdAt      DateTime    @default(now())
  updatedAt      DateTime    @updatedAt
  
  @@index([email])
  @@index([temperature])
  @@index([status])
  @@index([score])
  @@index([assignedToId])
  @@index([createdAt])
  @@map("leads")
}

enum LeadTemp {
  COLD
  WARM
  HOT
}

enum LeadStatus {
  NEW
  CONTACTED
  QUALIFIED
  VIEWING_SCHEDULED
  APPLICATION_STARTED
  APPLIED
  CONVERTED
  LOST
}

// AI Document Search & Chat Models
model Document {
  id            String      @id @default(cuid())
  filename      String
  originalName  String
  mimeType      String
  size          Int
  storageUrl    String      // S3 or local path
  processedText String?     // Extracted text content
  metadata      Json?       // OCR results, page count, etc
  
  // Relations
  propertyId    String?
  uploadedById  String
  property      Property?   @relation("PropertyDocuments", fields: [propertyId], references: [id])
  uploadedBy    User        @relation("UserDocuments", fields: [uploadedById], references: [id])
  
  createdAt     DateTime    @default(now())
  updatedAt     DateTime    @updatedAt

  @@index([propertyId])
  @@index([uploadedById])
  @@index([mimeType])
  @@map("documents")
}

model ChatSession {
  id         String        @id @default(cuid())
  userId     String
  title      String?       @default("New Chat")
  context    Json?         // Conversation context
  messages   ChatMessage[]
  user       User          @relation("UserChatSessions", fields: [userId], references: [id])
  createdAt  DateTime      @default(now())
  updatedAt  DateTime      @updatedAt

  @@index([userId])
  @@map("chat_sessions")
}

model ChatMessage {
  id          String      @id @default(cuid())
  sessionId   String
  role        String      // 'user' | 'assistant' | 'system'
  content     String      @db.Text
  metadata    Json?       // Sources, confidence, etc
  session     ChatSession @relation(fields: [sessionId], references: [id], onDelete: Cascade)
  createdAt   DateTime    @default(now())

  @@index([sessionId])
  @@index([role])
  @@map("chat_messages")
}
